"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDependencies = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const fs_1 = require("fs");
const path_1 = require("path");
const utils_1 = require("../utils");
/**
 * Computes a list of go modules.
 *
 * @param failSilently if true, the function will not throw an error if it fails
 */
const computeGoModules = (failSilently = false) => {
    const blocks = (0, utils_1.getGoModules)(devkit_1.workspaceRoot, failSilently);
    if (blocks != null) {
        return blocks
            .split('}')
            .filter((block) => block.trim().length > 0)
            .map((block) => JSON.parse(`${block}}`))
            .sort((module1, module2) => module1.Path.localeCompare(module2.Path))
            .reverse();
    }
    throw new Error('Cannot get list of Go modules');
};
/**
 * Extracts a map of project root to project name based on context.
 *
 * @param context the Nx graph context
 */
const extractProjectRootMap = (context) => Object.keys(context.projects).reduce((map, name) => {
    map.set(context.projects[name].root, name);
    return map;
}, new Map());
/**
 * Gets a list of go imports with associated module in the file.
 *
 * @param fileData file object computed by Nx
 * @param modules list of go modules
 */
const getFileModuleImports = (fileData, modules) => {
    var _a;
    const content = (_a = (0, fs_1.readFileSync)(fileData.file, 'utf-8')) === null || _a === void 0 ? void 0 : _a.toString();
    if (content == null) {
        return [];
    }
    return (0, utils_1.parseGoList)('import', content)
        .map((item) => (item.includes('"') ? item.split('"')[1] : item))
        .filter((item) => item != null)
        .map((item) => ({
        import: item,
        module: modules.find((mod) => item.startsWith(mod.Path)),
    }))
        .filter((item) => item.module);
};
/**
 * Gets the project name for the go import by getting the relative path for the import with in the go module system
 * then uses that to calculate the relative path on disk and looks up which project in the workspace the import is a part
 * of.
 *
 * @param projectRootMap map with project roots in the workspace
 * @param import the go import
 * @param module the go module
 */
const getProjectNameForGoImport = (projectRootMap, { import: goImport, module }) => {
    const relativeImportPath = goImport.substring(module.Path.length + 1);
    const relativeModuleDir = module.Dir.substring(devkit_1.workspaceRoot.length + 1).replace(/\\/g, '/');
    let projectPath = relativeModuleDir
        ? `${relativeModuleDir}/${relativeImportPath}`
        : relativeImportPath;
    while (projectPath !== '.') {
        if (projectPath.endsWith('/')) {
            projectPath = projectPath.slice(0, -1);
        }
        const projectName = projectRootMap.get(projectPath);
        if (projectName) {
            return projectName;
        }
        projectPath = (0, path_1.dirname)(projectPath);
    }
    return null;
};
const createDependencies = (options, context) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const dependencies = [];
    let goModules = null;
    let projectRootMap = null;
    for (const projectName in context.filesToProcess.projectFileMap) {
        const files = context.filesToProcess.projectFileMap[projectName].filter((file) => (0, path_1.extname)(file.file) === '.go');
        if (files.length > 0 && goModules == null) {
            goModules = computeGoModules(options === null || options === void 0 ? void 0 : options.skipGoDependencyCheck);
            projectRootMap = extractProjectRootMap(context);
        }
        for (const file of files) {
            dependencies.push(...getFileModuleImports(file, goModules)
                .map((goImport) => getProjectNameForGoImport(projectRootMap, goImport))
                .filter((target) => target != null)
                .map((target) => ({
                type: devkit_1.DependencyType.static,
                source: projectName,
                target: target,
                sourceFile: file.file,
            })));
        }
    }
    return dependencies;
});
exports.createDependencies = createDependencies;
//# sourceMappingURL=create-dependencies.js.map